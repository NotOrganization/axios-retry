{"version":3,"sources":["../es/index.js"],"names":["isNetworkError","axiosRetry","namespace","error","response","getCurrentState","config","currentState","retryCount","getRequestOptions","defaultOptions","Object","assign","fixConfig","axios","defaults","agent","httpAgent","httpsAgent","interceptors","use","Promise","reject","retries","retryCondition","delay","shouldRetry","code","isFunct","timeout","setTimeout","resolve","then","now","Date","lastRequestTime"],"mappings":";;;;;QAQgBA,c,GAAAA,c;kBAkFQC,U;;AA1FxB;;;;;;AAEA,IAAMC,YAAY,aAAlB;;AAEA;;;;AAIO,SAASF,cAAT,CAAwBG,KAAxB,EAA+B;AACpC,SAAO,CAACA,MAAMC,QAAd;AACD;;AAED;;;;;AAKA,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;AAC/B,MAAMC,eAAeD,OAAOJ,SAAP,KAAqB,EAA1C;AACAK,eAAaC,UAAb,GAA0BD,aAAaC,UAAb,IAA2B,CAArD;AACAF,SAAOJ,SAAP,IAAoBK,YAApB;AACA,SAAOA,YAAP;AACD;;AAED;;;;;;AAMA,SAASE,iBAAT,CAA2BH,MAA3B,EAAmCI,cAAnC,EAAmD;AACjD,SAAOC,OAAOC,MAAP,CAAc,EAAd,EAAkBF,cAAlB,EAAkCJ,OAAOJ,SAAP,CAAlC,CAAP;AACD;;AAED;;;;AAIA,SAASW,SAAT,CAAmBC,KAAnB,EAA0BR,MAA1B,EAAkC;AAChC,MAAIQ,MAAMC,QAAN,CAAeC,KAAf,KAAyBV,OAAOU,KAApC,EAA2C;AACzC,WAAOV,OAAOU,KAAd;AACD;AACD,MAAIF,MAAMC,QAAN,CAAeE,SAAf,KAA6BX,OAAOW,SAAxC,EAAmD;AACjD,WAAOX,OAAOW,SAAd;AACD;AACD,MAAIH,MAAMC,QAAN,CAAeG,UAAf,KAA8BZ,OAAOY,UAAzC,EAAqD;AACnD,WAAOZ,OAAOY,UAAd;AACD;AACF;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCe,SAASjB,UAAT,CAAoBa,KAApB,EAA2BJ,cAA3B,EAA2C;AACxDI,QAAMK,YAAN,CAAmBf,QAAnB,CAA4BgB,GAA5B,CAAgC,IAAhC,EAAsC,iBAAS;AAC7C,QAAMd,SAASH,MAAMG,MAArB;;AAEA;AACA,QAAI,CAACA,MAAL,EAAa;AACX,aAAOe,QAAQC,MAAR,CAAenB,KAAf,CAAP;AACD;;AAN4C,6BAYzCM,kBAAkBH,MAAlB,EAA0BI,cAA1B,CAZyC;AAAA,mDAS3Ca,OAT2C;AAAA,QAS3CA,OAT2C,yCASjC,CATiC;AAAA,oDAU3CC,cAV2C;AAAA,QAU3CA,cAV2C,0CAU1BxB,cAV0B;AAAA,mDAW3CyB,KAX2C;AAAA,QAW3CA,KAX2C,yCAWnC,CAXmC;;AAc7C,QAAMlB,eAAeF,gBAAgBC,MAAhB,CAArB;;AAEA,QAAMoB,cAAcF,eAAerB,KAAf,KACfA,MAAMwB,IAAN,KAAe,cADA,IAEfpB,aAAaC,UAAb,GAA0Be,OAFX,IAGf,8BAAepB,KAAf,CAHL;;AAKA,QAAIuB,WAAJ,EAAiB;AACfnB,mBAAaC,UAAb;;AAEA,aAAO,IAAIa,OAAJ,CAAY,mBAAW;AAC5B,YAAMO,UAAU,OAAOH,KAAP,KAAiB,UAAjC;AACA,YAAMI,UAAUD,UAAUH,MAAMlB,aAAaC,UAAnB,CAAV,GAA2CiB,KAA3D;AACAK,mBAAWC,OAAX,EAAoBF,OAApB;AACD,OAJM,EAKNG,IALM,CAKD,YAAM;AACV;AACA;AACAnB,kBAAUC,KAAV,EAAiBR,MAAjB;;AAEA,YAAM2B,MAAMC,KAAKD,GAAL,EAAZ;AACA,YAAI3B,OAAOuB,OAAP,IAAkBtB,aAAa4B,eAAnC,EAAoD;AAClD7B,iBAAOuB,OAAP,IAAkBI,MAAM1B,aAAa4B,eAArC;AACD;AACD5B,qBAAa4B,eAAb,GAA+BF,GAA/B;;AAEA,eAAOnB,MAAMR,MAAN,CAAP;AACD,OAjBM,CAAP;AAkBD;;AAED,WAAOe,QAAQC,MAAR,CAAenB,KAAf,CAAP;AACD,GA7CD;AA8CD","file":"index.js","sourcesContent":["import isRetryAllowed from 'is-retry-allowed';\n\nconst namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  return !error.response;\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\nfunction getCurrentState(config) {\n  const currentState = config[namespace] || {};\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace]);\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {number} [defaultOptions.retryCondition=isNetworkError] Number of retries\n * @param {number|function} [defaultOptions.delay=0] Delay between retries\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  axios.interceptors.response.use(null, error => {\n    const config = error.config;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const {\n      retries = 3,\n      retryCondition = isNetworkError,\n      delay = 0\n    } = getRequestOptions(config, defaultOptions);\n\n    const currentState = getCurrentState(config);\n\n    const shouldRetry = retryCondition(error)\n      && error.code !== 'ECONNABORTED'\n      && currentState.retryCount < retries\n      && isRetryAllowed(error);\n\n    if (shouldRetry) {\n      currentState.retryCount++;\n\n      return new Promise(resolve => {\n        const isFunct = typeof delay === 'function';\n        const timeout = isFunct ? delay(currentState.retryCount) : delay;\n        setTimeout(resolve, timeout);\n      })\n      .then(() => {\n        // Axios fails merging this configuration to the default configuration because it has\n        // an issue with circular structures: https://github.com/mzabriskie/axios/issues/370\n        fixConfig(axios, config);\n\n        const now = Date.now();\n        if (config.timeout && currentState.lastRequestTime) {\n          config.timeout -= now - currentState.lastRequestTime;\n        }\n        currentState.lastRequestTime = now;\n\n        return axios(config);\n      });\n    }\n\n    return Promise.reject(error);\n  });\n}\n"]}